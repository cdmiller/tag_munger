#!/usr/bin/env ruby

###########################
# lib_checker
#   takes an optional directory path as the root.
#   Searches the directory tree from root and creates a list of 
#   non-mp3 files and mp3 files. Then parses the mp3 metadata
#   reporting any files which don't match the desired tagging format
###########################

require 'optparse'
#require_relative '../lib/tag_munger' #the class that handles our munging
require 'yaml'
require 'pp'

VERSION="version 0.0.1"

my_options = {}
# defaults
my_options[:directory] = "."
my_options[:dry_run] = true

###########################################################
# Regular expressions to match the various filename formats
# Most course files will have a filename that matches the std_re
# Files that we segregate into special albums (chantings, dohas
# gongs, group sittings, hindi pdi's) need different re's and
# album name checks.  Also, one day courses, since their filnames
# do not start with a day number (D01) need a special check/re
#
##### below are the regular expression definitions ##############

std_re = /^.*\/D\d{1,2}_[\w\[\]\&\(\). -]+\.mp3$/ # matches <something, or nothing>/D0-99_<something>.mp3
# will work with tsc, satipatthana and any other multi-day course files
one_day_re = /^.*\/([^_]*_).*_1d\.mp3$/
metta_re = Regexp.new(".*\/Workers Metta 2005\/.*\.mp3$")
special_chantings_re = Regexp.new(".*\/Special Chantings\/.*\.mp3$")
group_sittings_re = Regexp.new(".*\/Groupsittings\/GSs English-only\/.*.mp3$")
bulk_group_sittings_re = Regexp.new(".*\/Groupsittings\/.*.mp3$")
gongs_re = Regexp.new(".*\/Sonos Customizations\/VMC Alarms\/.*\.mp3$")
dohas_re = Regexp.new(".*\/10 Day Dohas\/.*.mp3")
am_chantings_re = Regexp.new("(?<!Sonos Customizations/)10 Day Morning Chantings\/.*.mp3") #match 10 Day Morning... only if it is not a child dir of Sonos Customizations
hindi_pdi_re = Regexp.new("Sonos Customizations\/10D_Hindi_PDI\/.*\.mp3")
#
###### end of regular expression defs ##############

def parse_command_line(options)
  if ARGV.count == 0 #print help text if no options supplied
    ARGV << "--help"
  end

  opts = OptionParser.new do |opts|
    opts.banner = "\nUsage: lib_checker [options] \n" + 
      "Parses an input file generated by fix_lib -r and reports on suspicious album names/metadata"
    opts.version = VERSION

    opts.on("-i FILENAME", "--input FILENAME", 
            "\n\t\t Parses the file checking for correct filename-album name reations. File should be generated by fix_lib -r option.\n\n") do |file_name|
      options[:input] = file_name
  end

end

begin # enclose the commandline parsing in a rescue clause so that I can output
  # some custom error messages
  opts.parse!
rescue OptionParser::MissingArgument, OptionParser::InvalidOption
  puts "\n---> There is a problem with one of your command line arguments. Please check your options.<---\n"
  puts opts.help
  raise
end
end

parse_command_line(my_options)
puts "Command line options: #{my_options}"
# OK, we got valid commandline options so now lets get to work:


file_info =YAML::load_file(my_options[:input])

std_course_file, non_std_course_file = [], []
puts "\n#{file_info.count} files being checked."

file_info.each do |name, tags|
  # look for files with names formatted as D#_<whatever>_<courseName>d.mp3
  # these would be processed by our global album namer
  if name.match(std_re) # matches <something, or nothing>/D0-99_<something>.mp3
    std_course_file << name
  else
    non_std_course_file << name
  end
end
### do some extra sorting, because we want to treat dohas, 10D hindi PDI's
# and morning chantings  as non-standard files
std_course_file.each do |name|
  if name.match(dohas_re) || name.match(am_chantings_re) || name.match(hindi_pdi_re)
    non_std_course_file << name
  end
end
std_course_file.reject! { |name | name.match(dohas_re) || name.match(am_chantings_re) || name.match(hindi_pdi_re)}

counter = 0
puts "#{std_course_file.size} tracks/files  match the normal course/album algorithm."
# check that the album tags are correct for the easy files, 
# print 'em out if wrong
std_course_file.each do |key|
  w = (File.basename(key)).split("_")
  expected_album = [ w[0],  w[-1].chomp(".mp3")].join("_")

  if( expected_album != file_info[key]["album"])
    puts "wrong album #{file_info[key]["album"]} for file #{key}"
    counter = counter + 1
  end
end
puts (counter == 0 ? "\nAll #{std_course_file.count} tracks for std #day courses have the correct album title" : "\n#{counter} std course tracks have the wrong album title.")

#####################################
# check track number for discourses
counter = 0
discourse_counter = 0
puts "Checking std course discourse files for correct track number."
std_course_file.each do |key|
  if key.match(/.*_Disc_.*\.mp3/)
    discourse_counter = discourse_counter + 1
    if( 200 != file_info[key]["track"])
      puts "wrong track #{file_info[key]["track"]} for discourse file #{key}"
      counter = counter + 1
    end
  end
end
puts (counter == 0 ? "\nAll #{discourse_counter} discourse files for std #day courses have the correct track number" : "\n#{counter} discourse files have the wrong track number.")

################################
# process one day course albums
#
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(one_day_re) && (file_info[key]["album"] != "One Day Course")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for one day courses have the correct album title" : "\n#{counter} one day course tracks have the wrong album title.")
# remove one day courses from the non-std list so we don't have to continually re-process them
non_std_course_file.reject! { |name| name.match(one_day_re)}

################################
# Process workers metta files
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(metta_re) && (file_info[key]["album"] != "_Workers Metta")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for workers metta have the correct album title" : "\n#{counter} workers metta tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(metta_re)}

################################
# Process Special Chantings files
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(special_chantings_re) && (file_info[key]["album"] != "_Special Chantings")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for special chantings have the correct album title" : "\n#{counter} special chantings tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(special_chantings_re)}

################################
# Process Group Sittings files
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(group_sittings_re) && (file_info[key]["album"] != "_Group Sittings")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for english language group sittings have the correct album title" : "\n#{counter} english language group sittings tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(group_sittings_re)}

################################
# Process Gongs/alarms files
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(gongs_re) && (file_info[key]["album"] != "_Gongs")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for gongs have the correct album title" : "\n#{counter} gongs tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(gongs_re)}

################################
# Process Dohas files
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(dohas_re) && (file_info[key]["album"] != "_Dohas")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for dohas have the correct album title" : "\n#{counter} dohas tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(dohas_re)}

################################
# Process morning chanting files
puts "\n"
counter = 0
non_std_course_file.each do |key|
  if key.match(am_chantings_re) && (file_info[key]["album"] != "_10Day Morning Chantings")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end

puts (counter == 0 ? "\nAll tracks for morning chantings have the correct album title" : "\n#{counter} morning chantings tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(am_chantings_re)}

################################
# Process 10day hindi pdi files
puts "\nChecking for hindi pdi file in the Sonos Customizations dir"
counter = 0
found_at_least_one = false
non_std_course_file.each do |key|
  found_at_least_one = key.match(hindi_pdi_re) unless found_at_least_one
  if key.match(hindi_pdi_re) && (file_info[key]["album"] != "_Hindi PDIs")
    puts "wrong album <#{file_info[key]["album"]}> for file #{key}"
    counter = counter + 1
  end
end
puts "!!!!!!! no files were found that match #{hindi_pdi_re} THAT'S A BIG PROBLEM, LOOK INTO IT. !!!!!!!!!!!!" unless found_at_least_one
puts (counter == 0 ? "\nAll tracks found for the 10day hindi PDI's have the correct album title" : "\n#{counter} hindi pdi tracks have the wrong album title.")
non_std_course_file.reject! { |name| name.match(hindi_pdi_re)}

puts "\n#{non_std_course_file.size} files don't match any of our course/album algorithms."
puts "...removing non-english continuous group sittings files"
non_std_course_file.reject! { |name| name.match(bulk_group_sittings_re)}
puts "\nAfter removing the non-english group sittings files, \n#{non_std_course_file.size} files don't match any of our course/album algorithms."
puts "\n"
pp non_std_course_file
